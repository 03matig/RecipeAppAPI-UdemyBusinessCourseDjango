# RecipeAppAPI-UdemyBusinessCourseDjango
Recipe Django API project - Udemy Business Course

## Building Docker Image
docker build .

## Building docker compose
docker compose run *name_of_the_service*: what this does is to run a temporarily container based on the definition of the service *name_of_the_service*
docker compose up: what this does is to build the whole docker-compose.yml file, so if you define more than one service, you build all of those that are defined on the mentioned file.

### Project Setup
First thing you want to do, is to lift the django general project container, so you execute either:
```
django-admin startproject app .  # this inside the /app/ module you created manually by the time you want to setup the backend of your project
```
or (the one I recommend):
```
docker compose run --rm app sh -c "django-admin startproject app ."
```

By the time you want to create subapps, all you need to do is execute on your command prompt, powershell or anything you are using, either:
```
python manage.py startapp core
```
or:
```
docker compose run --rm app sh -c "python manage.py startapp core"
```

The previous command creates the template app to our project. After that, your directory should look something like this:
```bash
app/
├── app/               # directorio del proyecto (settings.py, urls.py, wsgi.py, asgi.py)
│   ├── settings.py
│   ├── urls.py
│   └── ...
├── manage.py
├── core/
│   ├── migrations/
│   ├── admin.py
│   ├── apps.py
│   ├── models.py
│   ├── tests.py
│   ├── views.py
│   └── ...

```

### Unit testing
docker-compose run --rm app sh -c "python manage.py test"
* Docker compose run --rm app: tells the terminal to run a temporarily container based on the definition of the service app, and to remove the container after it's done its jobs.
* sh -c: shell command "content inside the quotations is wrote in the shell"
* python manage.py test: Django framework integrated command for running the unit tests.

#### Test Driven Development - Django Test Running
The following command will run the whole test suite
```bash
python manage.py test
```

The following command will run the whole test suite using docker:
```
docker compose run --rm app sh -c "python manage.py test"
```

But if we want to execute a single command/function/test without mocking, we can use:
```
docker compose run --rm app sh -c "python manage.py name_of_the_command"
```

Applied example to this particular project:
```
docker compose run --rm app sh -c "python manage.py wait_for_db
```
The unit testing for this functionality mocks the DB behavior, but if you execute the single command, you get the actual behavior with the real db.

## Object Relational Mapper (ORM) - User Models
When you create a new Object (or want to create a new database table), you need the execute either:
```
python manage.py makemigrations
```

or

```
docker compose run --rm app sh -c "python manage.py makemigrations"
```
After you do that, there'll be a new file with auto-generated code to create a new model in our database in the file ./app/customApp/migrations/
It's the best to let Django handle this files and not to modify them under almost any circunstances (99.9% of the time).

Next thing to do, is to apply the migrations, which is done by either one of the following commands:
```
python manage.py migrate
```

or

```
docker compose run --rm app sh -c "python manage.py migrate"
```

What this does is to apply the migrations filed auto generated by Django on the database service lifted.

### Inconsistent Migration History

This can happen because we apply migrations previously with the default migrations that come in the background of Django that would use the default Django models, so we should clear the data of the database:

```
docker volume ls
docker volume rm ${name_of_the_project}${name_of_the_volume} # now data should be cleared
docker volume ls
docker compose run --rm app sh -c "python manage.py wait_for_db && python manage.py migrate"
```

If this doesn't work, it could be because the container is still running, which you can stop by executing:

```
docker stop <id_of_the_container>  # Now you can remove the volume
docker volume rm ${name_of_the_volume}
```

Other way to do it if stopping the container doesn't work, is:
```
docker compose down
docker compose up
```

The line you're looking for is: \
```app-1  |   Applying core.0001_initial... OK```

## Super User Creation

This is key so you can use the Django Admin User Interface. You can access this by directing yourself on your browser to the following URL: ```127.0.0.1:8000/admin``` and it will automatically redirect you to the admin user interface login page.
If you haven't created neither a superuser instance nor it's credentials, you can do it by Django command line:
```
python manage.py createsuperuser
```
or
```
docker compose run --rm app sh -c "python manage.py createsuperuser"
```
You expect to see some email and password requests. It all should look like this:
```
Email: youremail@example.com
Password:
Password (again):
Superuser created successfully.
```

## Flake8 Linting
Comments that tell flake8 to ignore respective file's errors:
```
# noqa
```

To visualize this phenomenon, you can check the app/core/admin.py file, as in first line there is a comment that says # noqa. When executing flake8, the output shouldn't show any linting related to that file.